<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-05-15">
<meta name="description" content="An overview of the Black-Scholes European option pricing model and a solution using the Monte-Carlo stochastic modeling technique">

<title>Pete Pritchard - BSM Monte Carlo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../..//Users/petepritchard/Documents/Projects/petepritch.github.io/assets/favicon-32x32.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Pete Pritchard</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preliminaries" id="toc-preliminaries" class="nav-link active" data-scroll-target="#preliminaries">Preliminaries</a></li>
  <li><a href="#formula" id="toc-formula" class="nav-link" data-scroll-target="#formula">Formula</a></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations">Limitations</a></li>
  <li><a href="#monte-carlo-simulation" id="toc-monte-carlo-simulation" class="nav-link" data-scroll-target="#monte-carlo-simulation">Monte Carlo Simulation</a></li>
  <li><a href="#more-preliminaries" id="toc-more-preliminaries" class="nav-link" data-scroll-target="#more-preliminaries">More Preliminaries</a></li>
  <li><a href="#computation" id="toc-computation" class="nav-link" data-scroll-target="#computation">Computation</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">BSM Monte Carlo</h1>
</div>

<div>
  <div class="description">
    <p>An overview of the Black-Scholes European option pricing model and a solution using the Monte-Carlo stochastic modeling technique</p>
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 15, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Predicting the direction of stock prices is an enticing provocation with the promise of a life of luxury and philanthropy. Alas, such a challenge is generally considered impossible given the complex nature of the stock market. However, there exists mathematical and statistical tools that can help us make useful predictions, manage risk, and profit probabilistically. This report serves as a both a introductory glimpse of the mathematical underpinnings as well as a reference to a number of theoretical and pragmatic resources on options trading. We briefly review the Black-Scholes European option pricing model and then solve it using the Monte-Carlo stochastic modeling technique.</p>
<hr>
<p>The Black-Scholes model is a mathematical formula used to estimate the fair price or theoretical value for a European call or put option. The model was developed by Fischer Black and Myron Scholes in 1973 in their paper <em>The pricing of options and corporate liabilities</em>, and later extended by Robert Merton <span class="citation" data-cites="BSM">(<a href="#ref-BSM" role="doc-biblioref">Black and Scholes 1973</a>)</span>. It is widely used in finance for option pricing, and has been recognized as a significant contribution to the development of modern financial mathematics theory. Scholes and Merton would eventually earn the 1997 Nobel Prize in Economics for their contributions. Black was ineligible for the award as he died a few years prior, however he was listed as a contributor.</p>
<p>The Black-Scholes model provides a way to determine the fair value of an option, which can be compared to the actual market price to determine if the option is overpriced or underpriced. It uses partial differential equations to calculate the expected payoff of the option at expiration, discounted to present value using the risk-free interest rate. The model has certain limitations, such as assuming constant volatility and not accounting for factors such as dividends or early exercise, but it is still widely used in practice and has led to the development of other models that incorporate additional factors. One of these popular model developments is incorporating Monte Carlo simulations.</p>
<p>Monte Carlo methods are a broad class of computational modeling techniques used to simulate and analyze complex systems or processes. This method and its name were inspired by the casinos of Monaco, and its approach involves generating a large number of random samples or “trials” to make conclusions with statistical significance. This technique has become wildly popular in computational finance, and is particularly useful when an option pricing formula is difficult or impossible to derive analytically <span class="citation" data-cites="MCM">(<a href="#ref-MCM" role="doc-biblioref">Johnson 2010</a>)</span>.</p>
<p>The remainder of this report is structured as the following; sections 2 and 3 take a deeper look into the mathematical underpinnings of the Black-Scholes and Monte Carlo methods for European option pricing. Section 4 demonstrates how to computationally put the models into production using Python, and compares the results of the two methods using simulated financial data. Lastly, we conclude and and mention a few ways this report can be extended.</p>
<section id="preliminaries" class="level3">
<h3 class="anchored" data-anchor-id="preliminaries">Preliminaries</h3>
<ul>
<li><p>A <strong>call option</strong> is a financial contract between a buyer and a seller that gives the buyer the right, but not the obligation, to buy an underlying asset at a specified price, known as the , at, or before, a certain date called <span class="math inline">\(maturity \ T\)</span> or the . The underlying asset can be a stock, currency, commodity, or any other financial instrument. The buyer purchases the option from the seller at price <span class="math inline">\(C(t)\)</span> at time <span class="math inline">\(t&lt;T\)</span> <span class="citation" data-cites="Wins">(<a href="#ref-Wins" role="doc-biblioref">Asiri 2018</a>)</span>.</p></li>
<li><p>A <strong>put option</strong> is a financial contract between a buyer and a seller that gives the buyer the right, but not the obligation, to sell an underlying asset at a specified price, known as the , at, or before, a certain date called <span class="math inline">\(maturity \ T\)</span> or the . The underlying asset can be a stock, currency, commodity, or any other financial instrument. The buyer purchases the option from the seller at price <span class="math inline">\(P(t)\)</span> at time <span class="math inline">\(t&lt;T\)</span> <span class="citation" data-cites="Wins">(<a href="#ref-Wins" role="doc-biblioref">Asiri 2018</a>)</span>.</p></li>
</ul>
<p>The buyer of the call/put option pays a premium to the seller for the right to buy/sell the underlying asset. For the call option, if the price of the underlying asset rises above the strike price <span class="math inline">\(K\)</span> before the expiration date, the buyer can exercise the option and buy the asset at the lower strike price, and then sell it on the open market for a profit. Whereas, for the put option, if the price of the underlying falls below the strike price before the expiration date, the buyer can exercise the option and sell the asset at a higher strike price, and then sell it on the open market for a profit.</p>
<p>A call or put option of an underlying option has a market, or today, price <span class="math inline">\(S(t)\)</span> and a future price <span class="math inline">\(S(T)\)</span>. We say a call option expires <em>in the money</em> when <span class="math inline">\(S(T)&gt;K\)</span>, <em>at the money</em> when <span class="math inline">\(S(T)=K\)</span>, and when <span class="math inline">\(S(T)&lt;K\)</span>. When an option expires out of the money, the buyer simply chooses not to exercise the option, and it expires worthless. For put options the lingo is similar, however the buyer is anticipating the asset price to drop, thus <em>in the money</em> when <span class="math inline">\(S(T)&lt;k\)</span>, so on and so forth.</p>
</section>
<section id="formula" class="level3">
<h3 class="anchored" data-anchor-id="formula">Formula</h3>
<p><span class="math display">\[\begin{equation}
C(S_{0},t)=S_{0}N(d_{1})-Ke^{-r(T-t)}N(d_{2})
\end{equation}\]</span> <span class="math display">\[\begin{equation}
P(S_{0},t)=N(-d_{2})Ke^{-r(T)}-N(d_{1})S_{0},
\end{equation}\]</span></p>
<p>where</p>
<ul>
<li><span class="math inline">\(S_{0}\)</span> is the stock price;</li>
<li><span class="math inline">\(C(S_{0},t)\)</span> is the price of a call option as a formulation of the stock price and time;</li>
<li><span class="math inline">\(P(S_{0},t)\)</span> is the price of a put option as a formulation of the stock price and time;</li>
<li><span class="math inline">\(K\)</span> is the strike price;</li>
<li><span class="math inline">\((T-t)\)</span> is the time to maturity, i.e.&nbsp;the exercise date <span class="math inline">\(T\)</span>, less the amount of time between now <span class="math inline">\(t\)</span> and then. Generally this is represented in years with one month equaling <span class="math inline">\(1/12\)</span>;</li>
<li><span class="math inline">\(N(d_{1})\)</span> and <span class="math inline">\(N(d_{2})\)</span> are the cumulative distribution functions for a standard normal distribution with the following formulation: <span class="math display">\[\begin{equation}
  d_{1}=\frac{ln\frac{S_{0}}{K}+(r+\frac{\sigma ^{2}}{2})(T-t)}{\sigma\sqrt{T-t}}
\end{equation}\]</span> <span class="math display">\[\begin{equation}
  d_{2}=d_{1}-\sigma\sqrt{(T-t)},
\end{equation}\]</span></li>
</ul>
<p>where</p>
<ul>
<li><span class="math inline">\(\sigma\)</span> represents the underlying volatility;</li>
<li><span class="math inline">\(r\)</span> is the risk-free interest rate </li>
</ul>
</section>
<section id="limitations" class="level3">
<h3 class="anchored" data-anchor-id="limitations">Limitations</h3>
<p>The Black-Scholes model makes a number of assumptions, however one of the most glaring issues is that it assumes stock returns are normally distributed. This implies that the volatility of the market is constant over time. Figure 1 shows the rolling average standard deviation for Microsoft daily close price over approximately ten years. Notice that the volatility is in no way stable.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rolling_vol.png" class="img-fluid figure-img"></p>
<figcaption>Rolling Volatility</figcaption>
</figure>
</div>
<p>Another key limitation of the Black-Scholes model is that it underestimates the tail density. Figure 2 shows a kernel density estimation plot with the empirical versus normal distribution for the Microsoft stock. Notice there are more returns at the extremities of the distributions than the normal distribution would predict. The phenomenon is known as “fat tails” or “excessive kurtosis,” and this suggests that the model will underestimate the value of out-of-the-money options <span class="citation" data-cites="BSCode">(<a href="#ref-BSCode" role="doc-biblioref">John 2020a</a>)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="tail_density.png" class="img-fluid figure-img"></p>
<figcaption>Tail Density</figcaption>
</figure>
</div>
</section>
<section id="monte-carlo-simulation" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-simulation">Monte Carlo Simulation</h3>
<p>Monte Carlo simulations are a popular and widely used method for pricing European options. This approach is particularly useful when the option pricing formula is difficult or impossible to derive analytically. In the Monte Carlo method, the future price of the underlying asset is modeled using random simulations, and the option price is calculated as the discounted expected value of the option’s payoff at the option expiration time.</p>
<p>Economist Phelim Boyle is credited for initiating the use of Monte Carlo methods in option pricing in his paper <em>Options: A Monte Carlo Appraoch</em>. One advantage of Boyle’s Monte Carlo approach is that it can be easily extended to handle more complex option types, such as options with early exercise features or options with multiple underlying assets. Additionally, the Monte Carlo method can be used to estimate the sensitivities of option prices to changes in the underlying asset’s parameters, such as volatility or interest rates <span class="citation" data-cites="MCapp">(<a href="#ref-MCapp" role="doc-biblioref">Boyle 1977</a>)</span>.</p>
<p>However, the Monte Carlo method can be computationally expensive, as it requires the generation of a large number of price paths to obtain an accurate estimate of the option price. Various techniques have been developed to improve the efficiency of Monte Carlo simulations, including variance reduction techniques such as control variates, antithetic variates, and importance sampling. Despite its computational complexity, the Monte Carlo simulation remains a valuable and widely used method for pricing European options.</p>
</section>
<section id="more-preliminaries" class="level3">
<h3 class="anchored" data-anchor-id="more-preliminaries">More Preliminaries</h3>
<ul>
<li><p><strong>Wiener Process</strong>, also known as <em>Brownian motion</em>, is a continuous stochastic process <span class="math inline">\(W(t)\)</span> with the following properties:</p>
<ul>
<li><span class="math inline">\(W(0)=0\)</span>.</li>
<li>For each <span class="math inline">\(t\)</span>, the random variable <span class="math inline">\(W(t)\)</span> is normally distributed with mean 0 and variance <span class="math inline">\(t\)</span>.</li>
<li>For each <span class="math inline">\(t_{1}&lt;t_{2}\)</span>, the normal random variable <span class="math inline">\(W(t_{2})-W(t_{1})\)</span> is independent of the random variable <span class="math inline">\(W(t_{1})\)</span>, and independent of all <span class="math inline">\(W(s),0\le s\le t_{1}\)</span>.</li>
<li>Wiener Process <span class="math inline">\(W(t)\)</span> can be represented by continuous paths <span class="citation" data-cites="NumA">(<a href="#ref-NumA" role="doc-biblioref">Sauer 2006</a>)</span>.</li>
</ul></li>
</ul>
<p>There are several research articles that take a deeper look into geometric Brownian motion, however, for the purpose of this topic, I found this interactive <a href="https://blog.skz.dev/monte-carlo-options-pricing">blog</a> to be very clear and well explained . Figure 3 visualizes simulated assets paths using Geometric Brownian motion.</p>
<ul>
<li><strong>Ito’s Lemma</strong> performs as the chain rule for stochastic calculus, similar to the chain rule in ordinary differential calculus. Specifically, it relates the partial differential of a function of a stochastic process to the drift rate, volatility, and their partial derivatives. The Ito formula is given below:</li>
</ul>
<p>If <span class="math inline">\(y=f(t,x)\)</span>, then</p>
<p><span class="math display">\[\begin{equation}
    dy=\frac{\partial f}{\partial x}(t,x)dt+\frac{\partial f}{\partial x}(t,x)dx+\frac{1}{2}\frac{\partial ^{2}f}{\partial x^{2}}(t,x)dxdx,
\end{equation}\]</span></p>
<p>where the <span class="math inline">\(dx\)</span><span class="math inline">\(dx\)</span> term is interpreted by using the identities <span class="math inline">\(dt\)</span><span class="math inline">\(dt=0\)</span>, <span class="math inline">\(dt\)</span><span class="math inline">\(dB_{t}=dB_{t}\)</span><span class="math inline">\(dt=0\)</span>, and <span class="math inline">\(dB_{t}dB_{t}=dt\)</span> <span class="citation" data-cites="NumA Courant">(<a href="#ref-NumA" role="doc-biblioref">Sauer 2006</a>; <a href="#ref-Courant" role="doc-biblioref">Goodman 2018</a>)</span>.</p>
<p>To apply the Monte Carlo simulation to price a European option, the first step is to generate a large number of random price paths for the underlying asset using a stochastic process such as geometric Brownian motion. Then, the payoff of the option is calculated for each of these price paths, and the average value is computed. Finally, the option price is determined by discounting the average payoff value to the present time.</p>
<p>The following equation was solved by the author of this <a href="https://www.codearmo.com/blog/pricing-options-monte-carlo-simulation-python">website</a> <span class="citation" data-cites="mcCode">(<a href="#ref-mcCode" role="doc-biblioref">John 2020b</a>)</span>.</p>
<p>Assume the stock price <span class="math inline">\(S\)</span>, pays annual dividend <span class="math inline">\(q\)</span> and has expected return <span class="math inline">\(\mu\)</span> equal to the risk free rate <span class="math inline">\(r-q\)</span>, the volatility <span class="math inline">\(\sigma\)</span> is assumed to be constant.</p>
<p>Essentially, the stock price can be modeled by a partial differential equation in which at least one of the terms is a stochastic random process. Let’s consider the case when volatility is 0.</p>
<p><span class="math display">\[\begin{equation}
    dS=\mu Sdt
\end{equation}\]</span> Given the price of the stock now <span class="math inline">\(S_{0}\)</span>, we can calculate the price <span class="math inline">\(S_{T}\)</span> at given time <span class="math inline">\(T\)</span> by separating and integrating as follows: <span class="math display">\[\begin{equation}
    \int_{0}^{T}\frac{dS}{S}=\int_{0}^{T}\mu dt
\end{equation}\]</span> Which gives: <span class="math display">\[\begin{equation}
    S_{T}=S_{0}e^{\mu T}
\end{equation}\]</span> <span class="math display">\[\begin{equation}
    ln(S_{T})=ln(S_{0})+\int_{0}^{T}\mu dt
\end{equation}\]</span> We need to include a stochastic term in the equation above to account for randomness in stock prices. By doing so, we get the following: <span class="math display">\[\begin{equation}
    dS=S\mu dt+S\sigma dW(t)
\end{equation}\]</span> Where <span class="math inline">\(W_{t}\)</span> is a Wiener Process, and now he equation is in the form on an Ito process. Ito’s lemma states if a random variable follows an Ito process then another twice differentiable function <span class="math inline">\(G\)</span> described by the stock price <span class="math inline">\(S\)</span> and time <span class="math inline">\(t\)</span> also follows an Ito process: <span class="math display">\[\begin{equation}
    dG=(\frac{\partial G}{\partial S}S\mu +\frac{\partial G}{\partial t}+\frac{1}{2}\frac{\partial ^{2}{G}}{\partial S^{2}}S^{2}\sigma ^{2})dt+\frac{\partial G}{\partial S}S\sigma dW(t)
\end{equation}\]</span> Applying Ito’s lemma to <span class="math inline">\(ln(S)\)</span> first we calculate the partial derivatives with respect to <span class="math inline">\(t\)</span> and <span class="math inline">\(S\)</span> as follows: <span class="math display">\[\begin{equation}
    G=ln(s)
\end{equation}\]</span> <span class="math display">\[\begin{equation}
    \frac{\partial G}{\partial S}=\frac{1}{S},\ \frac{\partial G}{\partial t}=0,\ \frac{\partial ^{2} G}{\partial S^{2}}=-\frac{1}{S^{2}}
\end{equation}\]</span> Plugging the partial derivatives into Ito’s lemma gives: <span class="math display">\[\begin{equation}
    dG=(\frac{1}{S}S\mu + 0-\frac{1}{2}\frac{1}{S^{2}}S^{2}\sigma ^{2})dt+\frac{1}{S}S\sigma dW(t)
\end{equation}\]</span> <span class="math display">\[\begin{equation}
    =(\mu - \frac{\sigma ^{2}}{2})dt+\sigma dW(t)
\end{equation}\]</span> Therefore, the distribution of <span class="math inline">\(ln(S_{T})-ln(S_{0})=(\mu -\frac{\sigma ^{2}}{2}T+\sigma \sqrt{T}\)</span>. The distribution of the stock price at expiration is given by rearranging the previous equation and taking the exponential of both sides: <span class="math display">\[\begin{equation}
    S_{T}=S_{0}e^{(\mu -\frac{\sigma ^{2}}{2})dt+\sigma dW(t)}
\end{equation}\]</span> This can also be written as: <span class="math display">\[\begin{equation}
    ln(S_{t})=ln(S_{0})+\int_{0}^{t}(\mu -\frac{\sigma ^{2}}{2})dt+\int_{0}^{t}\sigma dW(t), \ \ for \ t\in [0,\cdots ,T]
\end{equation}\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="geom_brownian.png" class="img-fluid figure-img"></p>
<figcaption>Geometric Brownian Motion</figcaption>
</figure>
</div>
</section>
<section id="computation" class="level3">
<h3 class="anchored" data-anchor-id="computation">Computation</h3>
<p>The following code was written using the Python programming language (version 3.8.2) along with the pandas, numpy, scipy, and matplotlib libraries. We use equation (1) and equation (17) to computer the estimate of a one month call option, or <span class="math inline">\(T=\frac{1}{2}\)</span> years, with the following parameter values: <span class="math inline">\(S=100\)</span>, <span class="math inline">\(K=110\)</span>, <span class="math inline">\(r=0.05\)</span>, <span class="math inline">\(q=0.02\)</span>, and <span class="math inline">\(\sigma =0.25\)</span>. A further look into the implementation of this code, and more work by the author can be found <a href="https://www.codearmo.com/blog/pricing-options-monte-carlo-simulation-python">here</a> <span class="citation" data-cites="mcCode">(<a href="#ref-mcCode" role="doc-biblioref">John 2020b</a>)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> black_scholes_call(S,K,T,r,q,sigma):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    # S = Current stock Price</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    # K = Strike Price</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    # T = Time to maturity 1 year = 1, 1 months = 1/12</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    # r = risk free interest rate</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    # q = dividend yield</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    # sigma = volatility </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Output</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">    # call_price = value of the option </span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(S<span class="op">/</span>K) <span class="op">+</span> (r <span class="op">-</span> q <span class="op">+</span> sigma<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>T) <span class="op">/</span> sigma<span class="op">*</span>np.sqrt(T)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> d1 <span class="op">-</span> sigma<span class="op">*</span> np.sqrt(T)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    call <span class="op">=</span> S <span class="op">*</span> np.exp(<span class="op">-</span>q<span class="op">*</span>T)<span class="op">*</span> norm.cdf(d1) <span class="op">-</span> K <span class="op">*</span> np.exp(<span class="op">-</span>r<span class="op">*</span>T)<span class="op">*</span>norm.cdf(d2)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> call</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> geo_paths(S, T, r, q, sigma, steps, N):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Input Parameters</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    # S = Current Stock Price</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    # K = Strike Price</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    # T = Time to maturity </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    # r = sirk free interest rate</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">    # q = dividend yield</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    # sgima = volatility</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Output</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    # [steps, N] Matrix of asset paths</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> T<span class="op">/</span>steps</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># S_{T} = ln(S_{0})+\int_{0}^T(\mu-\frac{\sigma^2}{2})dt+\int_{0}^T \sigma dW(t)</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    ST <span class="op">=</span> np.log(S) <span class="op">+</span>  np.cumsum(((r <span class="op">-</span> q <span class="op">-</span> sigma<span class="op">**</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>dt <span class="op">+\</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                              sigma<span class="op">*</span>np.sqrt(dt) <span class="op">*</span> <span class="op">\</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                              np.random.normal(size<span class="op">=</span>(steps,N))),axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(ST)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<table class="table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th>MCE(100)</th>
<th>MCE(1000)</th>
<th>MCE(10000)</th>
<th>MCE(100000)</th>
<th>Black-Scholes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C(100) = 4.0461</td>
<td>C(100) = 4.0003</td>
<td>C(100) = 3.8979</td>
<td>C(100) = 3.8187</td>
<td>C(100) = 3.7451</td>
</tr>
</tbody>
</table>
<p>Using the parameters given in Section 5, we will compare the accuracy of the Monte Carlo Methods to the exact Black-Scholes Equation. We repeat the procedure, increasing the number of trails <span class="math inline">\(N\)</span> from 100 to 100,000, and monitor how accuracy increases or decreases. The results are given in the table above. Notice how as <span class="math inline">\(N\)</span> increases the price approaches the Black-Scholes price.</p>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>As previously mentioned, this report is just the tip of the options pricing iceberg. There is seemingly no limit to the number of directions once can build upon Black, Scholes, and Merton’s historical work. The exploding development in technology over the past few decades has led to intense research and interest in this field. Mathematicians, Physicists, and Computer Scientists are flocking to Wall Street to build market-beating strategies. Although the Black-Scholes equation is a powerful, flexible, and easy to use tool for option pricing, it has its limitations. Financial traders and investors should be conscious of these drawbacks to use the equation appropriately.</p>
<p>Monte Carlo methods are more computationally expensive, take more time to calculate, and are less accurate for the simplest situations, however a closed solution like Black-Scholes is not always readily available or applicable. Furthermore, Monte Carlo provides a way to extended the Black-Scholes equation to a wider range of option types, and opens the doors to apply methods to more dynamic cases. Regardless of the method, both Black-Scholes and Monte Carlo simulation have helped to legitimize options trading, and serve as the fundamental strategy of eliminating risk associated with volatility, known as hedging.</p>
<p>A few simple ways in which this study can be extended:</p>
<ul>
<li>Develop a Monte Carlo method for American options or options with multiple underlying assets</li>
<li>Improve the efficiency of the Monte Carlo Method using techniques such as control variates, antithetic variates, and importance sampling</li>
<li>Test accuracy using real world financial data against actual brokers.</li>
</ul>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Wins" class="csl-entry" role="listitem">
Asiri, Fatimah Fathalden. 2018. <span>“The Price of Stocks, Geometric Brownian Motion, and Black Scholes Formula.”</span> <em>Major Papers</em> 26.
</div>
<div id="ref-BSM" class="csl-entry" role="listitem">
Black, Fischer, and Myron Scholes. 1973. <span>“The Pricing of Options and Corporate Liabilities.”</span> <em>The Journal of Political Economy</em> 81 (3): 637–54.
</div>
<div id="ref-MCapp" class="csl-entry" role="listitem">
Boyle, P. 1977. <span>“Options: A Monte Carlo Approach.”</span> <em>Journal of Financial Economics</em> 4 (3): 323–38.
</div>
<div id="ref-Courant" class="csl-entry" role="listitem">
Goodman, Jonathon. 2018. <span>“Lesson 4, Ito’s Lemma.”</span> Courant Insitute NYU.
</div>
<div id="ref-BSCode" class="csl-entry" role="listitem">
John. 2020a. <span>“Black Scholes Model Python.”</span> 2020. <a href="https://www.codearmo.com/python-tutorial/options-trading-black-scholes-model">https://www.codearmo.com/python-tutorial/options-trading-black-scholes-model</a>.
</div>
<div id="ref-mcCode" class="csl-entry" role="listitem">
———. 2020b. <span>“Pricing Options by Monte Carlo Simulation with Python.”</span> 2020. <a href="https://www.codearmo.com/blog/pricing-options-monte-carlo-simulation-python">https://www.codearmo.com/blog/pricing-options-monte-carlo-simulation-python</a>.
</div>
<div id="ref-MCM" class="csl-entry" role="listitem">
Johnson, A. M. 2010. <span>“Monte Carlo Methods.”</span> In <em>Encyclopedia of International Education (Third Edition)</em>, 296–303. Elsevier.
</div>
<div id="ref-NumA" class="csl-entry" role="listitem">
Sauer, Tim. 2006. <em>Numerical Analysis</em>. Reading, MA: Pearson Addison-Wesley.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024, Pete Pritchard</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <i class="fa-solid fa-heart" title="a heart" aria-label="heart"></i></p>
</div>
  </div>
</footer>




</body></html>